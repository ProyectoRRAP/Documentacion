%*******************************************************************************
%*********************************** First Chapter *****************************
%*******************************************************************************

\chapter{Estado del Arte}  %Title of the Second Chapter

\ifpdf
    \graphicspath{{Chapter2/Figs/Raster/}{Chapter2/Figs/PDF/}{Chapter2/Figs/}}
\else
    \graphicspath{{Chapter2/Figs/Vector/}{Chapter2/Figs/}}
\fi

En este capítulo se presentan los resultados obtenidos en el trabajo de investigación sobre el estado
del arte de las Redes Definidas por Software (Software Defined Networking), lenguajes
de programación y herramientas para el desarrollo sobre dicha arquitectura, hardware NetFPGA y otros conceptos esenciales para el desarrollo de este trabajo. En caso que el lector desee profundizar en alguno de los conceptos presentados en este cap\'itulo o consultar enfoques alternativos
y/o complementarios se recomiendan los siguientes trabajos \citep{StateOfArt1} y \citep{StateOfArt2}. Para el caso particular en que el lector est\'e familiarizándose con el enfoque de las Redes Definidas por Software, se sugiere también la lectura de \citep{SDNReadingList} y \citep{SDNBook1}.

En relación a c\'omo se estructura este cap\'itulo, primero se introduce el concepto de Software Defined Networking (SDN) analizando sus principales antecedentes para luego presentar una definición del concepto. Luego se presenta una de las arquitecturas existentes basadas en este enfoque y en particular utilizada en trabajo para la construcción de un prototipo. Se contin\'ua con la introducción de los conceptos Redes Privadas Virtuales y Multilabel Protocol Switch (\gloss{MPLS}) esenciales para el entendimiento de este trabajo. Finalmente se presenta el relevamiento en el estado del arte realizado sobre la plataforma NetFPGA.  

%********************************** %First Section  **************************************
\section{Antecedentes de SDN} %Section - 1.1
\label{section2.1}

Software Defined Networking, Redes Definidas por Software en español o simplemente SDN por su sigla en ingl\'es, es un concepto relativamente nuevo ya que bajo este nombre puede contextualizarse en la \'ultima década. No obstante muchas de las ideas que yacen detrás de este enfoque han sido introducidas por diferentes propuestas en el pasado. Por ello vale la pena repasar los principales antecedentes que desde nuestra perspectiva contribuyeron al enfoque de SDN. 

\subsection{Open Signaling}
En el año 1995 el grupo de investigación OPENSIG \cite{campbell1999open} dentro del \gloss{IETF}, comenzó a trabajar en alternativas para hacer ATM, Internet y las redes móviles ``más'' abiertas, extensibles y programables. El principal objetivo de este grupo fue proveer de un acceso al hardware de red (\gloss{router}s, \gloss{switch}es, etc) mediante un conjunto de interfaces abiertas. Con esto se buscaba permitir el despliegue de nuevos servicios de red a través de un ambiente de programación distribuido.

El principal desafío con el que tuvo que lidiar esta iniciativa fue la estricta arquitectura en forma vertical que presenta el hardware de red (modelo de capas OSI), cuya naturaleza a su vez solía ser cerrada. Esto dificultaba una estricta separación entre el software de control y el hardware.

Los esfuerzos de esta iniciativa desembocaron en la especificación del General Switch Managment Protocol (GSMP); un protocolo de propósito general para control de etiquetas en switches.
GSMP permitía a un controlador establecer y liberar conexiones en un dispositivo conmutador de tramas  
 (mejor conocido como switch), agregar, eliminar y dejar una conexión multicast, manejar los puertos de un switch, obtener información acerca de la configuración, obtener y eliminar recursos reservados en un switch y obtener información estadística. 

Tras años de trabajo, el grupo consider\'o concluida su labor, siendo su último trabajo publicado la especificación de GSMPv3 en Junio del 2002\cite{doria2002general}.

\subsection{Active Networking}
Active Networking \citep{tennenhouse1997survey},\citep{tennenhouse2002towards},\citep{moore2001towards} o Redes Activas en español es otra iniciativa que surge en la década de los 90's con la propuesta de una red programable que posibilitara la configuración de servicios sobre la misma. Fue propulsada por la USA Defense Advanced Research Projects Agency (DARPA), con el principal objetivo de acelerar la innovación en una área de redes marcada por la lentitud en incorporar nuevas tecnologías y servicios.

Se propusieron dos enfoques: (1) enfoque de Switches Programables en donde el tr\'afico es encaminado a través de nodos que ejecutan programas y cada paquete o su segmento correspondiente es derivado al programa apropiado en el nodo y (2) enfoque de C\'apsulas en donde cada paquete enviado en la red transporta un programa, evaluándose en cada nodo en su ambiente de ejecución correspondiente.

Como tal, este proyecto no alcanz\'o la suficiente masa cr\'itica como para imponerse en la industria, entre otras razones por la necesidad de un hardware diferente m\'as caro (tradicionalmente se utilizaba hardware de tipo \gloss{ASIC} y se requería de tipo \gloss{TCAM}, \gloss{FPGA} \'o \gloss{NPU}) adem\'as de interrogantes de seguridad y desarrollo de lenguajes de programación apropiados.

\subsection{Routing Control Platform}
Routing Control Platform (RCP) \citep{feamster2004case},\citep{caesar2005design} o Plataforma de Control de Ruteo, propone una entidad de control (Routing Control Platform) encargada de computar las rutas en una red, que luego utilizando protocolos estándares como iBGP traslada dicha configuración a los diferentes dispositivos. La principal ventaja de esta estrategia es que utiliza protocolos existentes estándares facilitando as\'i la transición entre el paradigma actual y el propuesto. No obstante su potencial se encontraba limitado justamente a las capacidades de los protocolos de comunicación existentes.

\subsection{ForCES Protocol}
Otro grupo de trabajo dentro del IETF denominado ForCES (Forwarding and Control Element Separation) comenzó a trabajar a mediados del año 2007 en un protocolo que permitiera la separación entre los dispositivos de red y la inteligencia que los gobierna. Dicho protocolo fue especificado como una propuesta de estándar y publicado en el año 2010 bajo el nombre ForCES Protocol 
 \citep{doria2010forwarding}.

Este enfoque plantea dos entidades lógicas denominadas Elementos de Control (CE) y Elementos de Reenv\'io (FE), así como un protocolo de comunicación entre ambas entidades.

\subsection{Proyecto 4D}
En el año 2004 el proyecto 4D \citep{rexford2004network},\citep{greenberg2005clean} propone una re-estructuración arquitectónica de una red basada en tres principios: 

\begin{itemize}
\item Políticas de red (network-level objectives): conjunto de objetivos o requerimientos sobre una red tales como performance, confiabilidad entre otras políticas.

\item Vistas de la red (network-wide views): vistas globales sobre la topolog\'ia de red, tr\'afico y eventos, con ciertos niveles de \gloss{frescura} y exactitud en los datos.

\item Control directo: se debe proveer una interfaz directa para el control de los dispositivos de red
\end{itemize}

Basándose en estos principios se construye el esquema denominado ``4D'' que merece su nombre por los cuatro planos presentes en su arquitectura: decisión (decision), diseminación (dissemination), descubrimiento (discovery) y datos (data).

\begin{figure}[h!] 
\centering    
\includegraphics[width=0.76\textwidth]{4DProject3}
\caption[Capas de la arquitectura]{Capas de la arquitectura. Imagen extraída de \cite{greenberg2005clean}}
\label{fig:4DProject}
\end{figure}

Dicha arquitectura hace un fuerte énfasis en una completa separación de lo que son las decisiones lógicas que toma un Sistema Autónomo (\gloss{AS}), del conjunto de protocolos que gobiernan las redes e interacciones entre sus diferentes componentes.

Los objetivos al nivel de un AS son especificados en el plano de decisiones y mediante los servicios de los planos de diseminación y descubrimiento se ejerce un control directo sobre c\'omo se encamina y redirigen paquetes en el plano de datos.

%En otras palabras el plano de decisión es responsable de crear la configuración de la red, mientras que el plano de diseminación se encarga de recolectar información sobre el estado de la red para el plano de decisión y distribuir la salida del plano de decisión. 

En resumen, utilizando el plano de diseminación se recolecta diferente información acerca del estado de la red, sobre la cual luego el plano de decisión construye las \textit{Políticas de red}. También a través del plano de diseminación se distribuyen dichas políticas a los distintos dispositivos de red. Mientras tanto el plano de descubrimiento permite a dispositivos descubrir vecinos directamente conectados en la red. Finalmente el plano de datos se encarga de redirigir el tráfico en la red. \\

Una vez introducidos los principales antecedentes de las redes definidas por software, en la siguiente secci\'on se propone profundizar en dicho concepto.

\section{Software Defined Networking}
\label{section2.2}

Definir el concepto de Software Defined Networking no es una tarea simple, puesto que no existe una definici\'on \'unica entre las distintas organizaciones que se encuentran trabajando en la temática. En particular se pueden destacar el grupo de trabajo Software-Defined Networking Research Group  
 (SDNRG) del \gloss{IRTF}, quien se encuentra trabajando en la redacción de las definiciones y estándares para este concepto y la organización Open Networking Foundation (ONF) \cite{ONF} que concentra gran cantidad de material y documentación sobre SDN y adem\'as se encuentra trabajando en el desarrollo del protocolo \gloss{OpenFlow} el cual se explica m\'as adelante en este trabajo.

Acorde a la Open Networking Foundation, SDN puede resumirse como:

\begin{quote}
\textit{``La separación física del plano de control de la red del plano de datos, y donde el plano de control controla varios dispositivos.''}
\end{quote}

Más en detalle, SDN es una arquitectura de red que desacopla los planos de control y de datos, moviendo el plano de control (inteligencia, construcción y c\'alculo de políticas de red) hacia una entidad denominada Controlador. Esto habilita al control de la red a ser directamente programable y a la infraestructura subyacente ser abstraída por las aplicaciones y servicios de red.

La ONF presenta a SDN como una arquitectura emergente, dinámica, escalable, rentable y adaptable, haciéndola ideal para aplicaciones de naturaleza dinámica y exigentes de los recursos de red disponibles. En particular destaca las cualidades de presentar una gestión centralizada y de estar basada en estándares abiertos neutrales a los vendedores.

\begin{figure}[htbp!] 
\centering    
\includegraphics[width=10cm]{SDNArchitecture}
\caption[Arquitectura de SDN - Capas lógicas]{Arquitectura de SDN - Capas lógicas. Imagen extraída de \cite{ONF}}
\label{fig:SDNArchitecture}
\end{figure}

El enfoque de SDN propone tres capas lógicas (ver imagen ~\ref{fig:SDNArchitecture}): (1) capa de aplicaciones (Application Layer), (2) capa de control (Control Layer) y (3) capa de infraestructura      
 (Infrastructure Layer).

La capa de infraestructura se compone por los dispositivos de red tradicionales como switches y routers, en particular compatibles con la arquitectura SDN. La inteligencia de estos dispositivos a diferencia de los convencionales es retirada de ellos para ser trasladada a la capa de control. A su vez, cada dispositivo implementa un conjunto de operaciones bien definidas mediante la cual es manipulado por la capa de control. Esta API de operaciones forma parte de lo que se denomina Interfaz Sur.

En la capa de control se encuentra el software encargado de implementar el plano de control en dicho modelo, usualmente denominado Controlador. Esta entidad expone un conjunto de operaciones a las aplicaciones SDN de la capa de Aplicación para la manipulación de los dispositivos de la capa inferior (capa de Infraestructura). Esta API de operaciones es conocida en el modelo bajo el nombre de Interfaz Norte.

La capa de aplicaciones, contiene implementado en software (aplicaciones SDN) toda la inteligencia que originalmente se agregaba en un dispositivo de la capa de infraestructura como por ejemplo la implementaci\'on de protocolos de red. En dicha capa se pueden implementar desde protocolos de ruteo como OSPF y \gloss{RIP}, backbones sobre MPLS, políticas de seguridad y hasta aplicaciones de Ingeniería de tráfico. N\'otese aqu\'i la diferencia entre la capa de aplicaci\'on del modelo de capas OSI y la capa de aplicaci\'on  del modelo SDN. En el modelo SDN, una aplicaci\'on puede implementar protocolos y servicios de capa de enlace, capa de red y capas superiores en el modelo OSI.

De esta forma Software Defined Networking centraliza el control de la red en una aplicación de software (Controlador) y transforma algoritmos, procesos de control, políticas de seguridad y toda la inteligencia antiguamente acoplados a los dispositivos de red, en aplicaciones de controlador.

\section{Arquitecturas basadas en SDN}
\label{section2.3}

Existen varias arquitecturas o implementaciones en las que de una forma u otra puede encontrarse argumentos para afirmar que siguen el enfoque de SDN. Si bien este trabajo se basa en la utilización de la arquitectura OpenFlow, existen otras arquitecturas basadas en este enfoque como el protocolo ForCES y alternativas m\'as comerciales como OpFlex \cite{OpFlex}.

A continuaci\'on se explican los principales conceptos relacionados a la arquitectura OpenFlow.

\subsection{OpenFlow}

Siguiendo el enfoque de tres capas de SDN y bajo la misma premisa de desacoplar completamente los planos de datos y control, OpenFlow \cite{mckeown2008openflow} brinda una implementaci\'on estándar para el mecanismo de comunicación entre las capas de control e infraestructura (Interfaz Sur). En otras palabras, provee un protocolo de comunicación estándar para manipular los distintos dispositivos de la red y así el plano de datos.

OpenFlow se basa en tres componentes (ver figura ~\ref{fig:OpenFlowArch}): (1) Controlador OpenFlow compatible, (2) Protocolo OpenFlow y (3) Switch OpenFlow compatible.

  
%OpenFlow logra estandarizar la forma mediante la cual cada entrada de la tabla de flujos en un switch, puede ser modificada externamente (Protocolo OpenFlow), brindando un mecanismo transparente y confiable para la manipulación del plano de datos en los switches compatibles con OpenFlow independientemente del vendedor y fabricante del equipo.\\

%Un switch OpenFlow, como se ilustra en la Figura 6, esta compuesto al menos por 3 partes: (1) Una Tabla de Flujos (Flow Table), con una acción asociada a cada flujo en la misma(Flow table entry) para decirle al switch como procesar cada flujo, (2) un Canal Seguro (Secure Channel) que conecta el switch con un proceso de control remoto (Controlador) permitiendo enviar comandos y paquetes entre el controlador y el switch utilizando (3) el protocolo OpenFlow el cual provee una forma abierta y estándar de comunicación entre el controlador y el switch.\\

\begin{figure}[htbp!] 
\centering    
\includegraphics[width=7cm]{OpenFlowArchitecture1}
\caption[Estructura de un switch OpenFlow]{Estructura de un switch OpenFlow. Imagen extraída de \cite{mckeown2008openflow}}
\label{fig:OpenFlowArch}
\end{figure}

Desde la perspectiva de un Controlador OpenFlow, todos los dispositivos de red son equivalentes en sus funcionalidades y se denominan simplemente switches OpenFlow. Un switch OpenFlow se compone de tres componentes principales (ver figura ~\ref{fig:OpenFlowArch}): (1) Tabla de flujos, (2) Canal Seguro 
 (Secure Channel) que conecta el switch con el Controlador habilitando el intercambio de paquetes y comandos entre estos últimos dos utilizando (3) el protocolo OpenFlow.
 
\begin{figure}[h!] 
\centering    
\includegraphics[width=9cm]{OpenFlowArchitecture2}
\caption[Visión esquemática del funcionamiento de un Switch OpenFlow]{Visión esquemática del funcionamiento de un Switch OpenFlow. Imagen extraída de \cite{mckeown2008openflow}}
\label{fig:OpenFlowArch2}
\end{figure}

Cada switch OpenFlow presenta una o m\'as tablas de flujos, compuestas por entradas denominadas flujo, las cuales determinan c\'omo una clase de paquetes deben ser procesados y reenviados. Cada entrada o flujo (ver figura ~\ref{fig:OpenFlowArch2}) se compone de: (1) campos de selección (matching fields), utilizados en la definici\'on de reglas de selección con las cuales identificar a un conjunto de paquetes a ser tratados de una forma en particular, basándose en información relacionada a campos en los cabezales del paquete para esto; (2) contadores para la recolección de información estadística en relación al flujo (n\'umero de paquetes recibidos, cantidad de bytes, duración de un flujo, etc.) y (3) un conjunto de instrucciones y acciones que son aplicadas a cada paquete que coincide con la regla del flujo. Estos campos establecen la forma en que un paquete es procesado y reenviado.

\begin{figure}[h!] 
\centering    
\includegraphics[width=12cm]{OFPacketProcessing}
\caption[Ciclo de vida de un paquete en pipe OpenFlow]{Ciclo de vida de un paquete en el pipe OpenFlow}
\label{fig:OFPacketProcessing}
\end{figure}
 
Cuando un paquete arriba a un switch (ver figura ~\ref{fig:OFPacketProcessing}), se extraen y comparan cabezales del paquete acorde a las reglas definidas en el flujo, comparando los campos utilizados. En caso que el paquete coincida con las reglas definidas, se aplican el conjunto de instrucciones y acciones asociadas a dicho flujo. En caso que el paquete no coincida con ningún flujo, el accionar a desempeñar dependerá del conjunto de instrucciones y acciones definidas por una entrada especial en la tabla de flujos, denominada Table-miss Flow Entry.

La Table-miss Flow Entry est\'a pensada para contemplar el tipo de tr\'afico que no es definido por ningún otro flujo, por ello en esencia es el \'ultimo flujo a ser considerado (menor prioridad) al momento de procesar un paquete. Generalmente tiene asociada la acción de eliminar el paquete (Drop), procesar el paquete en la siguiente tabla de flujos (GoTo Table) \'o reenviar el paquete al Controlador.

Otra caracter\'istica importante de un switch OpenFlow, es la capacidad para procesar paquetes utilizando protocolos tradicionales de red adem\'as del procesamiento normal de OpenFlow. Esta característica a su vez da lugar a la clasificaci\'on en switches OpenFlow puros y switches OpenFlow h\'ibridos. Mientras que los switches OpenFlow puros son aquellos que solamente soportan el protocolo de igual nombre, los switches OpenFlow h\'ibridos son aquellos que adicionalmente permiten procesar paquetes de la misma forma en que lo har\'ia un hardware de red legado.

Aprovechando las capacidades de un switch OpenFlow h\'ibrido, se puede definir por ejemplo la Table-miss-Flow-Entry de forma que se procese todo paquete contemplado por esta entrada como un hardware de red tradicional, aplicando por ejemplo esquemas de reenvío IP. 

\subsection{Reglas OpenFlow}
Cada entrada en la tabla de flujos, distingue un tipo de tr\'afico en particular y la forma en que se procesa (acciones e instrucciones). Es uno de los pilares del protocolo la expresividad disponible para escribir las reglas de cada flujo; es decir, la capacidad de agrupar tipos de tr\'afico acorde a diferentes propiedades en el mismo.

\begin{figure}[h] 
\centering    
\includegraphics[width=6cm]{ofv1MF}
\caption[OF 1.0 Matching Fields]{OpenFlow v1.0 Matching Fields}
\label{fig:OF10MatchingFields}
\end{figure}

Las reglas OpenFlow se basan en los valores de cabezales asociados a diferentes capas del modelo OSI. Estos cabezales a su vez varían con la versi\'on del protocolo, incorporándose m\'as opciones en cada versi\'on del mismo. Por ejemplo en la versi\'on 1.0 del protocolo se tiene un soporte mínimo para cabezales de capas 1 a 4 (ver imagen ~\ref{fig:OF10MatchingFields}).

Por otro lado en la versi\'on 1.3.3 del protocolo se cuenta con soporte para utilizar cabezales de IPv6, ICMPv6 y MPLS en la definición de los flujos (ver imagen ~\ref{fig:OF13MatchingFields}).
 
\begin{figure}[ht] 
\centering    
\includegraphics[width=6cm]{ofv13MF}
\caption[OF 1.3.3 Matching Fields]{OF 1.3.3 Matching Fields}
\label{fig:OF13MatchingFields}
\end{figure}

\subsection{Acciones OpenFlow}

Como se menciona anteriormente la acci\'on de un flujo OpenFlow determina la forma en que un paquete es procesado en un switch. Las tres acciones principales que todo switch OpenFlow debe implementar son:

\begin{enumerate}
\item \textbf{[Output:Puerto]:} Reenviar un paquete hacia un puerto determinado (o conjunto de puertos). Esto permite encaminar paquetes a través de la red.

\item \textbf{[Output:Controller]:} Encapsular y reenviar un paquete hacia el Controlador. Utilizando el canal de comunicación con el Controlador y el protocolo OpenFlow, se reenvía el paquete al plano de Control. Esto permite procesar un paquete no identificado en ningún flujo en cualquier momento como por ejemplo en una etapa de configuración de la red. Luego el Controlador decide si descartar el paquete o instalar un nuevo flujo que lo contemple.

\item \textbf{[Drop]:} Descartar un paquete. Puede ser utilizado por razones de seguridad, para prevenir ataques de denegación de servicios (\gloss{DoS}), eliminar paquetes sospechosos, disminuir el impacto de paquetes de descubrimiento en redes de difusión (broadcast), o simplemente descartar paquetes no contemplados.
\end{enumerate}

\subsection{Controlador OpenFlow}
Un controlador SDN brinda implementaciones a las interfaces Sur y Norte. Un controlador OpenFlow/SDN requiere adem\'as de esto la compatibilidad con el protocolo OpenFlow en la interfaz Sur. 

Basándose solamente en estos principios, las implementaciones de controladores OpenFlow pueden ser muy variadas. Desde controladores muy simples como NOX\cite{ControllersNOX} y POX\cite{ControllersPOX} que siguen estrictamente el enfoque de SDN/OpenFlow, hasta controladores m\'as elaborados como OpenDaylight \cite{ControllersOpendaylight} (ver imagen ~\ref{fig:OpenDayLightHydrogen}) que implementan OpenFlow como una característica m\'as de su implementaci\'on de interfaz Sur.

Sin embargo existen aspectos relacionados a la entidad Controlador dentro del enfoque OpenFlow/SDN que son afines a cualquier implementaci\'on y arquitectura. A continuaci\'on se mencionan los principales:
  
\begin{figure}[h!] 
\centering    
\includegraphics[width=0.8\textwidth]{opendaylight-hydrogen}
\caption[Arquitectura de OpenDaylight Hydrogen]{Arquitectura de OpenDaylight Hydrogen. Imagen extraída de \cite{OpenDaylightArch}}
\label{fig:OpenDayLightHydrogen}
\end{figure}

\newpage
\subsubsection{Granularidad en el control}
Tradicionalmente, la unidad básica de tráfico en una red es el paquete. Cada paquete contiene información de direccionamiento necesaria para la toma de decisiones dentro del switch a nivel de reenvío. Sin embargo muchas aplicaciones de red envían datos como un flujo de muchos paquetes individuales, mientras que las redes que desean proveer de calidad de servicios (\gloss{QoS}) se benefician utilizando flujos. Por ello resulta beneficioso adoptar un nivel de abstracción superior en el control del plano de datos, distinguiendo tr\'afico por flujos y no a través de paquetes individuales.
 
Por otro lado uno de los puntos vulnerables del enfoque SDN, es la comunicación entre switch y Controlador. Sobrecargar este canal de comunicación, pensando en redes a gran escala en la cantidad de dispositivos, supone una debilidad importante. Basar la granularidad de control en paquetes individuales, profundiza esta debilidad; mientras que el enfoque basado en flujos atenúa esta debilidad. 

Para fijar ideas, en el enfoque de flujos, cuando un paquete recibido no es contemplado por ning\'un flujo particular puede ser reenviado al Controlador para decidir su procesamiento. Este, tras analizar dicho paquete puede resolver adem\'as del procesamiento instalar un nuevo flujo para contemplar m\'as adelante paquetes similares (incluyendo al mismo paquete). De esta forma cualquier otro paquete contemplado por el nuevo flujo no es m\'as reenviado al Controlador, mientras que en el enfoque de paquetes individuales la regla instalada contemplar\'ia solamente al paquete inicial.

A su vez se pueden utilizar las mismas prácticas que con el control a nivel
de paquetes individuales, como agrupar flujos relacionados al tráfico entre dos hosts, tomando
decisiones sobre los flujos agregados. 

\subsubsection{Centralizado vs Distribuido}
SDN no establece ninguna restricción en cuanto a si el plano de control debe ser tanto lógica como físicamente centralizado o distribuido. De hecho resulta conveniente pensar en enfoques distribuidos cuando se piensa en arquitecturas robustas y escalables. No es el objetivo de este trabajo profundizar en esta área de investigación por lo cual se recomienda para profundizar sobre esta temática las referencias \cite{heller2012controller} y \cite{levin2012logically}. 

En relación a OpenFlow, si bien el protocolo no establece mecanismos para la comunicación entre controladores, habilita a un switch a conectarse a múltiples controladores. Algunos proyectos como Onix \cite{koponen2014distributed} e HyperFlow \cite{tootoonchian2010hyperflow} toman la idea de mantener un plano de control lógicamente centralizado pero físicamente distribuido. Este enfoque tiene como principal beneficio disminuir la sobrecarga en el proceso de búsqueda sobre una tabla de flujos, permitiendo la comunicación con controladores locales. Por otro lado, Kandoo
 \cite{hassas2012kandoo} proponen utilizar controladores locales para el manejo de aplicaciones y redirigir hacia un Controlador global flujos que requieran de una visión global del estado de la red, bastante similar a lo anterior. Esto tiene como principal beneficio la reducción de la carga sobre el Controlador global, debido al filtrado de solicitudes de flujo que realizan los controladores locales a la vez proveen al plano de datos de una rápida respuesta para las solicitudes que pueden ser manejadas por los controladores locales. Finalmente otro de los enfoques que buscan generar una distribución del plano de control en SDN es el asumido por FlowVisor \cite{sherwood2010carving}, el cual propone la virtualización de una red de switches OpenFlow con múltiples controladores, construyendo lo que denominan Slices de la red. De esta forma brindan a cada controlador una visión local a su Slice, mientras que un controlador especial act\'ua de \gloss{Proxy} manteniendo una visión global de toda la red.

\subsubsection{Políticas reactivas vs proactivas}
Existen dos enfoques para la intervención del controlador en el plano de datos: (1) reactivo y (2) proactivo.

\begin{enumerate}
\item \textbf{Instalación reactiva de políticas:} En este enfoque, un switch se configura con la tabla de flujos vac\'ia o al menos una configuración mínima al encenderse. Luego, cada vez que un paquete arriba al switch y no es contemplado por ning\'un flujo, es reenviado al Controlador. Este decide que hacer con el paquete e instala un flujo en el dispositivo para procesar de igual forma paquetes similares.

Este modelo adoptado en particular por Ethane \cite{casado2007ethane}, presenta como principal desventaja la sobrecarga en el canal de comunicación Switch-Controlador. Por ello juega un rol sumamente importante en este esquema la definición de los flujos (flujos m\'as generales disminuyen la sobrecarga con el controlador y flujos muy específicos aumentan esta sobrecarga), tiempo de vida de los flujos en la tabla (flujos con tiempo de vida de un solo paquete aumentan la sobrecarga), la ubicación física del controlador y las características del canal de comunicación. Utilizando una jerarquía de controladores, canales de comunicación de alta velocidad o redundancia de enlaces, se puede mejorar la penalizaci\'on en los tiempos de respuesta por la sobrecarga del canal de comunicación. 

\item \textbf{Instalación proactiva de políticas:} En este enfoque, un switch se configura con la mayor cantidad de flujos posibles, contemplando la mayor cantidad de tr\'afico en la red al momento de encender el switch. Luego, cuando un paquete ingresa al switch, en caso de no ser contemplado por ninguno de los flujos instalados, se reenvía al Controlador para decidir c\'omo actuar. Luego el Controlador puede instalar un flujo para contemplar el caso asociado a este paquete. 

En \cite{yu2011scalable} se analiza el impacto de utilizar un enfoque de políticas proactivas en la performance de una red.  

\end{enumerate} 

%\subsubsection{Escalabilidad}
%[No se si aplique hablar de esto capaz es mucho]

\section{Herramientas SDN/OpenFlow disponibles}
\label{section2.4}

La principal herramienta para el desarrollo de aplicaciones SDN/OpenFlow es el software de control o Controlador. No obstante también existen entornos de emulación compatibles con estas tecnologías y que merecen la pena ser mencionados en este trabajo por su utilidad.

\subsection{Controlador}
Existe un cantidad interesante de propuestas para la implementaci\'on del plano de control. En este trabajo se ha mencionado algunos como OpenDaylight, NOX y POX, pero existen varias alternativas. Pueden encontrarse desde controladores comerciales y académicos, en código abierto y propietario, compatibles solamente con OpenFlow y compatibles con múltiples protocolos incluyendo OpenFlow, etc.

Estas características son utilizadas en este proyecto para la elección de la mejor alternativa de software de control, basándose en las necesidades y restricciones del prototipo. Por ello se cree conveniente incluir el siguiente cuadro comparativo (ver tabla \ref{table:Controladores}), en el que se presentan las principales características utilizadas en la elecci\'on del controlador m\'as apropiado. Cabe destacar que esta tabla est\'a basada en una tabla m\'as reducida presentada en \cite{StateOfArt1}.

\newpage
\clearpage
\begin{table}[htbp!]
\fontsize{7pt}{8pt}\selectfont
\begin{tabular}{|l|l|l|p{2cm}|l|p{5cm}|}
\hline   
\textbf{Controlador} & \textbf{Implementación} & \textbf{Opensource} & \textbf{Desarrollador}         & \textbf{OpenFlow} & \textbf{Detalle}                                                                                                                                                                                                                                                                                                          \\
\hline
POX\cite{ControllersPOX}                  & Python                  & Si                  & Nicira                         & 1.0               & Controlador de propósito general implementado en Python, compatible con Linux, Mac OS, y Windows.                                                                                                                                                                                                                         \\
\hline
NOX\cite{ControllersNOX}                  & C++                     & Si                  & Nicira                         & 1.0               & Uno de los primeros controladores ampliamente utilizado. Implementa funcionalidades para descubrimiento de topologías, learning switch y Network-wide switch.                                                                                                                    \\
\hline
OpenMUL\cite{ControllersOpenMUL}          & C                       & Si                  & Kulcloud                       & 1.4               & Controlador basado en OpenFlow con compatibilidad hacia atrás (OpenFow v1.0, v1.2, etc) con soporte multi-thread basado en lenguaje C, soporte SSL, soporte a múltiples interfaces norte, API REST                                                                                                                        \\
\hline
Maestro\cite{ControllersMaestro}              & Java                    & Si                  & Rice University                & -                 & Maestro es un controlador orientado a la orquestaci\'on de aplicaciones de control de red. Provee interfaces para el acceso y modificación de los dispositivos de la red a estas aplicaciones, as\'i como para coordinar la interacci\'on entre ellas. \\
\hline
Trema\cite{ControllersTrema}                & Ruby/C                  & Si                  & NEC                            & 1.0               & Framework full-stack para el desarrollo de Controladores OpenFlow en Ruby y C, compatible con Ubuntu 13.04 y Fedora 16-19 entre otras distribuciones Linux.                                                                                                                                                                \\
\hline
Beacon\cite{ControllersBeacon}           & Java                    & Si                  & Stanford                       & 1.0              & Controlador multi-plataforma, rápido y modular basado en OpenFlow con soporte a programación orientada a eventos y concurrente (threads). Incorpora la plataforma web Jetty y un m\'odulo GUI extensible.                                                                                                                   \\
\hline
Jaxon\cite{ControllersJaxon}                & Java                    & Si                  & Desarrolladores independientes & 1.0              & Controlador OpenFlow basado en NOX para desarrollo en  Java.                                                                                                                                                                                                                                                              \\
\hline
Helios\cite{ControllersHelios}               & C                       & No                  & NEC                            & -                 & Controlador basado en OpenFlow orientado a lenguaje C, extensible. Interfaz de comunicación Norte en formato Shell.                                                                                                                                                                                                       \\
\hline
Floodlight\cite{ControllersFloodlight}           & Java                    & Si                  & BigSwitch                      & 1.3               & Controlador SDN basado en OpenFlow, soporte para switches virtuales y físicos, maneja redes OpenFlow y redes no OpenFlow así como islas OpenFlow, soporte a OpenStack.                                                                                                                                                     \\
\hline
SNAC\cite{ControllersSNAC}                 & C++                     & No                  & Nicira                         & -                 & Controlador basado en OpenFlow para redes LAN con GUI y un lenguaje definido para declarar reglas. Est\'a basado en el controlador NOX más un módulo para un lenguaje de modelado formal  
 (FML).                                                                                                                             \\
\hline
\gloss{Ryu}\cite{ControllersRyu}                  & Python                  & Si                  & NTT, OSRG group                & 1.4               & Framework de programación para SDN, provee controladores basados en OpenFlow, Netconf, Of-config entre otros. Brinda soporte para OpenFlow v1.0 v1.2 v1.3 y v1.4 y extensiones propuestas por le empresa Nicira.                                                                                                                                    \\
\hline
Nodeflow\cite{ControllersNodeFlow}             & Javascript              & Si                  & NTT, OSRG group                &                   & Controlador basado en OpenFlow orientado a programación en Javascript, basado en el framework Node.js.                                                                                                                                                                                                                    \\
\hline
OVS-Controller\cite{OVSController}       & C                       & Si                  & Desarrolladores independientes & -                 & Controlador basado en OpenFlow de referencia con soporte a Open vSwitch y gran parte de otros tipos de switches. \\
\hline
FlowVisor\cite{ControllersFlowvisor}            & C                       & Si                  & Stanford/Nicira                & -                 & Controlador de propósitos particulares, que actúa como proxy de forma transparente entre una red OpenFlow y múltiples Controladores OpenFlow.                                                                                                                                                                             \\
\hline
RouteFlow\cite{ControllersRouteflow}            & C++                     & Si                  & CPqD                           & 1.3               & Proyecto Open Source que provee servicios de routing virtualizados sobre hardware OpenFlow. Un escenario de uso común puede ser su utilización en conjunto con otro Controlador como Ryu.                                                                                                                                \\
\hline
OpenDaylight\cite{ControllersOpendaylight}         & Java                   & Si                  & Linux Foundation               & 1.3               & Open Daylight es un framework abierto a la comunidad y apoyado por fabricantes, orientado a mejorar y agilizar la adopción de nuevos protocolos y aplicaciones así como la innovación. Este controlador esta desarrollado en java y provee diferentes m\'odulos de conexión para la interfaz Sur, entre los cuales se encuentra el protocolo OpenFlow. Brinda soporte al protocolo OpenFlow hasta versión 1.3 actualmente.\\
\hline   
\end{tabular}
\caption[Principales controladores disponibles]{Principales controladores disponibles (Basada en una tabla similar y más reducida en \cite{StateOfArt1})}
\label{table:Controladores}
\end{table}

\newpage
\subsection{Mininet y miniNExT}
Mininet \cite{Mininet1} es un emulador de red, que habilita a crear hosts, switches, links y controladores, en un entorno virtual. Se encuentra disponible tanto para instalarse nativamente en un entorno Linux, como a través de una m\'aquina virtual configurada con todo el software de desarrollo necesario para iniciarse en el desarrollo de aplicaciones OpenFlow/SDN (Mininet Kit Starter). 

Soporta diferentes versiones del protocolo OpenFlow y es una de las herramientas m\'as utilizadas para la prototipaci\'on y experimentación de aplicaciones desarrolladas en dicha arquitectura, puesto que habilita a investigadores y desarrolladores aprender, prototipar, probar y depurar aplicaciones rápidamente utilizando una computadora convencional.

Por otro lado, la herramienta miniNExT \cite{MiniNext} es una extensi\'on de Mininet que permite entre otras cosas asignar a cada host su propio sistema de ficheros, permitiendo as\'i modificar la configuraci\'on por defecto de cada nodo virtual e instalar diferentes herramientas en ellos. Est\'a orientado al despliegue virtual de arquitecturas m\'as complejas que las soportadas por Mininet.  

En este trabajo Mininet es utilizado para realizar pruebas de experimentaci\'on y comparación entre las alternativas de controladores disponibles, con el objetivo de determinar el controlador OpenFlow a ser utilizado en la arquitectura del prototipo.

\section{Aplicaciones de SDN}
\label{section2.5}

SDN presenta un campo de aplicación bastante extenso y es posible que a medida que el concepto siga evolucionando y asentándose se irán descubriendo nuevos casos de uso y campos de aplicación. A continuación se muestran algunos casos de uso:

\begin{itemize}

\item \textbf{Monitorizaci\'on de Red:}
En una arquitectura OpenFlow por ejemplo, cada switch provee información estadística (similar a SNMP) de cada flujo en tiempo real. De esta forma un Controlador puede recolectar información estadística sobre el tráfico en el plano de datos, lo cual es de gran interés para operadores de red y aplicaciones, con la granularidad exacta que estos requieran. Esta información puede ser agregada de diferentes formas: por dirección IP, por dirección MAC, etiquetas VLAN, por aplicación, etc. De esta forma se logra una gran versatilidad en la entrega de información estadística sobre el tráfico en una red.

\item \textbf{Redes \gloss{Tap} programables:}
Utilizando OpenFlow se pueden implementar taps de redes programables en forma centralizada de una forma simple, transparente y eficiente. También pueden filtrarse los datos que son enviados por ejemplo a un sistema de detección de intrusos (IDS), reduciendo la carga de trabajo a los dispositivos de procesamiento de datos utilizados, filtrando previamente los datos que son realmente necesarios y evitando replicar datos innecesarios.\\
Además desde que el control de los dispositivos intermediarios puede realizarse desde un controlador, se facilita enormemente la gestión de los mismos, permitiendo una configuración dinámica en caso de fallas o averías técnicas.

%Utilizando OpenFlow se pueden implementar redes taps
%programables y replicar el tráfico para su monitoreo de una forma más eficiente que los
%métodos tradicionales de SPAN/RSPAN. También pueden filtrarse los datos que son
%enviados por ejemplo a un sistema de detección de intrusos(IDS), reduciendo la carga
%de trabajo a los dispositivos de procesamiento de datos utilizados, filtrando previamente
%los datos que son realmente necesarios y evitando replicar datos innecesarios.
%Además desde que el control de los dispositivos intermediarios puede realizarse desde
%un controlador, se facilita enormemente a gestión de los mismos, permitiendo una
%configuración dinámica en caso de fallas o averías técnicas.

\item \textbf{Balanceo de carga y QoS:}
Contar con una visión global de los dispositivos del plano de datos, habilita al Controlador a implementar diferentes políticas de balanceo de carga en función del estado de la red y permite un uso óptimo de todos los recursos disponibles. A su vez se pueden priorizar diferentes tipos de tráfico, encaminar tráfico dependiendo de un tipo de servicio o contenido y otras técnicas de QoS.

\item \textbf{Herramientas para mitigación de ataques DoS:}
Herramientas para la mitigación de ataques de denegación de servicios (DoS) pueden beneficiarse de las estadísticas provistas por un switch OpenFlow por ejemplo para detectar anomalías. Además utilizando la acción de redirección de un flujo al Controlador se puede analizar y detectar tráfico sospechoso de ataques DoS, permitiendo a posteriori insertar un flujo en el switch de ingreso específico para bloquear el tipo de ataque o tráfico malicioso detectado. 

De todos modos vale la pena recordar la inconveniencia de sobrecargar el canal de comunicaci\'on entre un dispositivo y el controlador. 

\item \textbf{Implementaci\'on de Servicios de red:}
Con una arquitectura basada en SDN como OpenFlow, resulta sumamente sencillo la incorporación de servicios al plano de datos de una infraestructura de red dada. Independientemente de la marca del hardware utilizado, sus características y funcionalidades, siempre que sean compatibles con OpenFlow puede incorporarse nuevos servicios como autenticación, firewall, almacenamiento secundario, etc., simplemente programando una nueva aplicación en el Controlador que implemente dichos servicios.

\item \textbf{Experimentación:}
El desarrollo, verificación y puesta en producción de nuevos servicios y protocolos resulta sumamente sencillo puesto que consta simplemente de desplegar una nueva aplicación en un entorno de software 
 (Controlador). Por ello resulta sumamente útil el enfoque de SDN para la academia y la industria en lo que refiere al desarrollo de nuevos protocolos de red, nuevos servicios, mejoras a servicios existentes, entre otros.

\end{itemize}

Por estas razones soluciones basadas en el enfoque SDN con OpenFlow por ejemplo u otras arquitecturas basadas en SDN resultan de gran utilidad en escenarios como:

\begin{enumerate}
\item Redes empresariales
\item Centros de cómputo (Data Centers)
\item Academia
\end{enumerate}

\section{Casos de éxito de SDN/OpenFlow}
\label{section2.6}

OpenFlow en particular se ha hecho con un cierto protagonismo recientemente. Tal es el hecho que se pueden nombrar casos de éxito en la migración de servicios sobre esquemas tradicionales de redes a SDN/OpenFlow. Por ejemplo, la Open Networking Foundation elabor\'o un art\'iculo \cite{ONFSuccessCase} en donde se recomiendan métodos y se proveen guías para la migración de servicios desde un esquema tradicional a SDN nombrando en particular tres casos de éxito en este tipo de migraciones, en escenarios reales: (1) Google InterDatacenter WAN, (2) NTT Provider Edge y (3) Stanford Campus Network.

Por mayores detalles en relación a estos casos de \'exito se recomienda continuar con la lectura en dicho art\'iculo.

\section{Red Privada Virtual}
\label{section2.7}

En pocas palabras una Red Privada Virtual o VPN por su sigla en ingl\'es, es la extensi\'on de una red privada sobre una infraestructura de red p\'ublica como lo es por ejemplo Internet.

Este concepto habilita a un equipo en una determinada subred privada a enviar y recibir información a otro equipo en otra subred separadas f\'isicamente, utilizando una infraestructura de red p\'ublica o compartida para la comunicaci\'on entre ambas subredes, y de la misma forma que si estuviese directamente conectada a la red privada. Adem\'as permite mantener las políticas de seguridad y funcionalidades de la red privada.

Las implementaciones de redes privadas se caracterizan entre otras cosas por las funcionalidades que son capaces de proveer. En relaci\'on a aspectos de seguridad se buscan principalmente funcionalidades de autenticaci\'on de usuarios, confidencialidad e integridad de los datos. Por otro lado en relaci\'on al procesamiento del tr\'afico dentro de la red p\'ublica, algunas implementaciones de VPN ofrecen funcionalidades de clasificaci\'on de tr\'afico y calidad de servicios (QoS), permitiendo por ejemplo garantizar un ancho de banda m\'inimo para el tr\'afico de una organizaci\'on cuando es transportado a trav\'es de la red p\'ublica de una red privada a otra. 

Algunas implementaciones proveen adem\'as la capacidad de priorizar tipos de tr\'afico como por ejemplo el asociado a una aplicaci\'on en particular, o distribu\'ir la carga entre diferentes caminos, lo que se conoce como balanceo de carga.

En relaci\'on a la implementaci\'on de redes privadas, a lo largo de los años han surgido diferentes alternativas diferenciándose por las funcionalidades que implementan y tambi\'en por las capas en el stack OSI en la cual operan. Algunos ejemplos son: 

\begin{itemize}
\item VPN tradicionales
	\begin{itemize}
	\item Frame Relay (Capa 2)	
	\item ATM (Capa 2)
	\end{itemize}
	
\item VPNs basadas en \gloss{CPE}
	\begin{itemize}
	\item \gloss{L2}TP (Capa 2)
	\item IPSec (Capa 2)
	\end{itemize}
	
\item VPNs implementadas por proveedores de servicios
	\begin{itemize}
	\item VPN de capa 2 con MPLS
	\item \gloss{BGP}/MPLS VPNs de capa 3
	\end{itemize}
\end{itemize}

Otra de las características por la cual es interesante diferenciar a dichas implementaciones, es la capacidad de conectar dos o m\'as puntos de una red privada, lo cual da lugar a redes privadas punto a punto o multipunto.

\subsubsection{Redes Privadas Punto a Punto}

Las redes privadas punto a punto (ver figura \ref{fig:VPNPuntoAPunto}) son un tipo de implementaci\'on orientada a conectar solamente dos extremos de la red de una organizaci\'on, utilizando lo que se denominan t\'uneles sobre la infraestructura de un proveedor de servicios o Internet. T\'ipicamente se utilizan para conectar un cliente con un servidor en una organizaci\'on cuando se encuentran f\'isicamente separados, o dos edificios de una misma organizaci\'on de una forma simple. 

\begin{figure}[htbp!] 
\centering    
\includegraphics[width=0.7\textwidth]{VPNPuntoaPunto}
\caption[Esquema de una VPN Punto a Punto]{Esquema de una VPN Punto a Punto}
\label{fig:VPNPuntoAPunto}
\end{figure}

En este enfoque el tr\'afico de la subred A al llegar al router VPN, es encapsulado y enviado a trav\'es de un túnel sobre la red p\'ublica. Al llegar al otro extremo del túnel el tr\'afico es desencapsulado en el router VPN y entregado a la subred B, tomando luego el camino correspondiente dentro de la misma en forma normal. Esto genera la percepci\'on desde ambas subredes que se tiene un “cable” entre ambos routers VPN, conectando ambas subredes como si fuesen una sola red privada.
 
\subsubsection{Redes Privadas Multipunto}

Las redes privadas multipunto, extienden el enfoque punto a punto con el objetivo de brindar conectividad a una organizaci\'on dispersa geogr\'aficamente en m\'ultiples lugares. Permiten establecer dominios de difusi\'on compartidos, creando de forma transparente la ilusi\'on de que se tiene una gran LAN compuesta por varias subredes. Sin embargo al ser m\'as complejas en funcionalidades y casos de uso soportados, tambi\'en son m\'as complejas de implementar.

Virtual Private LAN Service (VPLS), es una implementaci\'on de red privada multipunto, bastante difundida y provista de los dos enfoques definidos en los \gloss{RFC}4761 \citep{kompella2007virtual} y RFC4762 \cite{lasserre2007virtual}. Esta implementaci\'on crea dominios de difusión Ethernet utilizando diferentes tecnologías como IP/MPLS, L2TPv3 y túneles GRE.

\begin{figure}[htbp!] 
\centering    
\includegraphics[width=0.7\textwidth]{VPNMultipunto}
\caption[Esquema de una VPN Multipunto \gloss{L3}]{Esquema de una VPN Multipunto L3}
\label{fig:VPNMulipunto}
\end{figure}
 
En una red privada multipunto de capa 3 como la de la figura \ref{fig:VPNMulipunto}, compuesta por las subredes A, B y C, cuando se origina un paquete en un equipo de la subred A con destino a otro equipo en la subred B sucede lo siguiente: (1) primero el paquete es encaminado al nodo de borde de la subred A (Router VPN), (2) luego se resuelve din\'amicamente a qu\'e punto de la VPN debe ser enviado el paquete (subred B o subred C), para lo cual se utiliza un protocolo de ruteo de borde como BGP, después (3) el paquete es encapsulado dentro de MPLS y encaminado mediante conmutaci\'on de etiquetas hasta el nodo de borde en la subred B, finalmente (4) el paquete es desencapsulado y entregado a la subred B para ser encaminado en forma normal hacia el equipo destino.

\subsection{Redes Privadas en Uruguay y proyecciones para la RAU}
En Uruguay ANTEL (el principal proveedor de servicios de telecomunicaciones del país) ofrece servicios de redes privadas basados en tres tecnolog\'ias principalmente\footnote{Informaci\'on extra\'ida en base a los servicios comerciales ofrecidos por ANTEL en su sitio oficial \cite{ANTELVPN}.}: 

\begin{itemize}
\item Lan to Lan con conexiones Ethernet punto a punto
\item VLAN Hub con conexiones Ethernet 
\item VPN IP/MPLS multipunto con QoS opcionalmente
\end{itemize} 

Dentro de las proyecciones existentes para la RAU2, se encuentran funcionalidades como calidad de servicios, clasificaci\'on de tr\'afico y priorizaci\'on del mismo de acuerdo a pol\'iticas definidas. A su vez se busca conectar m\'ultiples oficinas y organizaciones dispersas geográficamente en todo el país, manteniendo las pol\'iticas de seguridad de la red privada de cada organizaci\'on. 

De acuerdo a las implementaciones mencionadas anteriormente, la soluci\'on que m\'as se adapta a los requerimientos de la RAU2 es una VPN IP/MPLS multipunto con funcionalidades de QoS, en donde el rol de proveedor de servicios lo asume la propia red académica o la organizaci\'on encargada de su mantenimiento (SeCIU). Para complementar la lectura en relaci\'on a este tipo de implementaci\'on recomendamos continuar con RFC2547 \citep{rosen1999bgp} y RFC4364 \citep{rosen2006bgp}.

\section{Multiprotocol Label Switching}
\label{section2.8}

Multiprotocol Label Switching (MPLS) o conmutación de etiquetas con soporte para múltiples protocolos, es un mecanismo de transporte de datos desarrollado y estandarizado por el IETF, en particular por los RFC 3031 \cite{rosen2001multiprotocol}, 3032 \citep{rosen2001mpls} y 3814 \citep{nadeau2004multiprotocol}. De acuerdo al modelo de capas OSI, opera entre las capas de Red y Enlace y fue diseñado para unificar el servicio de transporte de datos basado en circuitos virtuales y en conmutación de paquetes.

MPLS sustituy\'o a los servicios de Frame Relay y ATM en la construcci\'on de servicios de redes privadas, siendo hoy en d\'ia el est\'andard de facto para esto y contando con una amplia adopci\'on de fabricantes. Entre sus cualidades m\'as importantes se distinguen soporte para VPNs, Ingeniería de Tráfico, calidad de servicios (QoS), clases de servicios (CoS), a la vez que es independiente del protocolo de capa de enlace pudiendo operar por ejemplo sobre ATM ó Ethernet.

En una red MPLS, cuando un paquete ingresa se le coloca un cabezal compuesto por cuatro campos: Label, Exp, S, TTL. De ellos se destacan el valor de la etiqueta MPLS, utilizada para encaminar paquetes a través de la red hacia su nodo destino y eventualmente realizar clasificación de tr\'afico. Este cabezal es extraído y analizado en cada nodo de la red para determinar el próximo nodo al que se debe enviar dicho paquete, colocando un nuevo cabezal con un nuevo valor de etiqueta antes de reenviarse. De esta forma el paquete es encaminado dentro de la red MPLS mediante la conmutaci\'on de etiquetas, hasta que el paquete arriba a un nodo de salida de la red, en donde ya no contiene etiquetas.

Por otro lado, un paquete MPLS puede presentar más de un cabezal MPLS solapado. Esta superposición de etiquetas se conoce bajo el nombre de pila o stack MPLS. De esta forma se pueden agregar más variables al servicio que simplemente encaminar paquetes en la red, como puede ser distinguir entre diferentes tipos de tráfico.

Otro punto a destacar de este protocolo es la configuración del plano de reenvío. El plano de control de las redes MPLS se compone de un algoritmo de ruteo y un algoritmo de distribución de etiquetas. Mientras que con el primero se calculan los mejores caminos que un paquete debe tomar para atravesar la red, el segundo se encarga de la asignación y distribución de etiquetas para que cada switch conmute correctamente el paquete hasta su destino.

Algunos de los principales términos en la arquitectura MPLS son:

\begin{itemize}
\item LER (Label Edge Router): Elemento de la red MPLS por la cual ingresa o egresa tráfico hacia o desde la misma.
\item LSR (Label Switching Router): Elemento de la red MPLS que conmuta etiquetas.
\item FEC (Forwarding Equivalence Class): Nombre asignado al tráfico que es encaminado bajo una misma etiqueta. En otras palabras, es una clase de equivalencia de tráfico a la cual se le asigna una etiqueta.
\item LSP (Label Switched Path): Nombre genérico que se le asigna a un camino MPLS para tráfico de una determinada FEC, es decir un túnel MPLS establecido entre dos extremos de la red.
\item \gloss{LDP} (Label Distribution Protocol): Protocolo de distribución de etiquetas MPLS entre los equipos de la red.
 
\end{itemize}

En la siguiente secci\'on se presenta un resumen del estudio en el estado del arte realizado sobre la plataforma NetFPGA.

\section{NetFPGA}
\label{section2.9}

NetFPGA \cite{NetFPGA} es una plataforma de hardware reconfigurable y software de c\'odigo abierto  
 (Open Source), flexible y potente, diseñada para un uso académico en tareas de investigación y enseñanza.

El hardware est\'a basado en un chip FPGA (Field Programmable Gate Array), el cual se programa con lenguajes de descripci\'on de hardware (\gloss{HDL}) como por ejemplo \gloss{VeriLog}. Cuenta con una amplia variedad de proyectos desarrollados tanto por el equipo de NetFPGA (proyectos de referencia), como por instituciones académicas y comerciales involucradas (proyectos comunitarios) que permiten programar el comportamiento del hardware  de diferentes formas. Se pueden encontrar desde proyectos que programan el hardware con una implementación de referencia de una tarjeta de red (Reference NIC), como un Learning Switch, Simple Router, Router OpenFlow, hasta un generador de tr\'afico entre otros  
 (por mayor informaci\'on ver \citep{NetFPGA2}).

Surge en el año 2007 como un proyecto de investigación en la Universidad de Stanford bajo el nombre de NetFPGA-1G, con la consigna de construir una plataforma de desarrollo e investigación basada en un chip FPGA. La versi\'on comercial alcanzada consisti\'o en una placa PCI con un chip Xilinx Virtex-II proFPGA y cuatro interfaces Ethernet de 1Gigabit, m\'as un repositorio de código fuente descargable y abierto a la comunidad, conteniendo librerías IP y unos pocos ejemplos de diseño.

El proyecto prosper\'o vendiendo m\'as de 2.600 tarjetas en 150 instituciones educativas en 15 países diferentes del mundo hasta el momento en que se discontinu\'o dicho producto.

Tras el éxito de la NetFPGA-1G, en el año 2009 comenzó a trabajarse en la NetFPGA-10G una versi\'on m\'as potente que la  anterior basada en un chip Xilinx Virtex5 y cuatro interfaces 10-Gigabit SFP+, que remplazaría a la NetFPGA-1G. Tras iniciarse su comercialización en el año 2011 la misma cosech\'o un éxito similar a su antecesora llegando a vender m\'as de 470 unidades al año 2014, y contando con una plataforma de al menos 15 proyectos desarrollados específicamente para esta plataforma.

A la fecha, NetFPGA cuenta con cuatro versiones de plataformas comerciales, la NetFPGA-1G  
 (discontinuada), NetFPGA-10G, NetFPGA CML y NetFPGA-SUME. A su vez la plataforma se ha popularizado entre investigadores y desarrolladores como plataforma ideal para la experimentación e innovación, contando a la fecha con m\'as de 226 artículos académicos \cite{NetFPGA4} en diversas áreas, utilizando como plataforma de trabajo NetFPGA.

En resumen NetFPGA es una plataforma robusta que propicia a investigadores, docentes y estudiantes en el área de redes de computadoras a la construcción de prototipos sobre sistemas de redes de alta velocidad y acelerados por hardware, en poco tiempo y con un costo inferior a otras alternativas de prototipaci\'on.

En este trabajo, se utiliza la plataforma NetFPGA-10G para la prototipaci\'on de un dispositivo compatible con OpenFlow a partir del cual a su vez implementar una red prototipo basada en el enfoque OpenFlow/SDN. 

